JVM体系结构与运行原理:
    Java语言写的源程序通过Java编译器，编译成与平台无关的‘字节码程序’(.class文件，也就是0，1二进制程序)，然后
在OS之上的Java解释器中解释执行。


类的加载过程：
    装载、验证、准备、解析、初始化
    其中除了解析其他四个步骤的发生顺序是可以确定的，解析过程不确定（他在某些情况下可以在初始化阶段开始之后）
    此外这几个阶段只是按照顺序开始，并不是一定按照顺序进行或者完成，通常是互相交叉混合进行的


JVM整个类加载过程的步骤：
1. 装载

    首先通过一个类的全名来获取其定义的二进制字节流，其次将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，
    最后在堆中生成一个代表这个类的java.lang.class对象，作为对方法区中这些数据的访问入口

    简单理解来说就是：
    装载过程负责找到二进制字节码并加载至JVM中，JVM通过类名、类所在的包名通过ClassLoader来完成类的加载，
    同样，也采用以上三个元素来标识一个被加载了的类：类名+包名+ClassLoader实例ID。


2. 链接

    链接的作用是验证，以确保被加载的类的正确性

    通俗来说：
    链接过程负责对二进制字节码的格式进行校验、初始化装载类中的静态变量以及解析类中调用的接口、类。

    尽管验证阶段这么重要，但却不是必须的

3. 准备

    完成校验后，为JVM初始化类中的类变量分配内存，并将其值赋为默认值。

    注意：
        1>这个时候进行内存分配的仅仅是类变量static，而不包括实例变量，实例变量是随着对象一块分配在Java堆中
        2>初始值是零值，而非Java代码中被显式赋予的值
        3>如果一个字段同时被final和static修饰，那么它会被初始化城显式赋予的值（可以理解为static final常量在编译期就将其结果放入了调用他的类的常量池中）

    最后对类中的所有属性、方法进行验证，以确保其需要调用的属性、方法存在，以及具备应的权限（例如public、private域权限等），会造成NoSuchMethodError、NoSuchFieldError等错误信息。

4. 解析

    解析阶段是把类中的符号引用转换为直接引用

    解析动作主要针对类或者接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符七类符号进行引用

    符号引用就是一组符号来描述目标，可以是任何字面量
    直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄

3. 初始化

    初始化过程即为执行类中的静态初始化代码、构造器代码以及静态属性的初始化，
    在六种情况下初始化过程会被触发执行：
        创建类的实例，也就是new；
        访问类的或接口的静态变量或对其赋值；
        调用类的静态方法；
        反射调用了类中的方法；
        初始化子类，则其父类也会被初始化；
        JVM启动过程中指定的初始化类。

-------------------------------------------------------------------------------------------------------------------------------

类加载器

类加载器大致可以划分为三类：

1. 启动类加载器 Bootstrap ClassLoader
    该类存放在jdk\jre\lib

2. 扩展类加载器 Extension ClassLoader
3. 应用程序类加载器 Appliaction ClassLoader


-------------------------------------------------------------------------------------------------------------------------------
JVM类加载机制

1. 全盘负责
    当一个类加载器负责加载某个class时，该class所依赖的和引用的其他class也将由该类加载器载入，除非显式的委托其他的类加载器进行加载

2. 父类委托
    先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类

3. 缓存机制
    确保加载过的类都会被缓存。当程序中需要某个class时类加载器先从缓存区寻找，找不到时才会读取该类对应的二进制数据并将其转换成class对象
    这就是为什么修改了class后，必须重启JVM，修改的程序才会生效


-------------------------------------------------------------------------------------------------------------------------------

类加载器
类加载有三种方式：
    1、命令行启动应用时候由JVM初始化加载
    2、通过Class.forName()方法动态加载
    3、通过ClassLoader.loadClass()方法动态加载

    例子：
        public class loaderTest {
                public static void main(String[] args) throws ClassNotFoundException {
                        ClassLoader loader = HelloWorld.class.getClassLoader();
                        System.out.println(loader);
                        //使用ClassLoader.loadClass()来加载类，不会执行初始化块
                        loader.loadClass("Test2");
                        //使用Class.forName()来加载类，默认会执行初始化块
                        //Class.forName("Test2");
                        //使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块
                        //Class.forName("Test2", false, loader);
                }
        }

    demo：
        public class Test2 {
                static {
                        System.out.println("静态初始化块执行了！");
                }
        }

Class.forName()和ClassLoader.loadClass()区别：

    Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；
    ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。
    Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象

-------------------------------------------------------------------------------------------------------------------------------

ClassLoader抽象类的几个关键方法：

   （1）loadClass

        此方法负责加载指定名字的类，ClassLoader的实现方法为先从已经加载的类中寻找，如没有则继续从parent ClassLoader中寻找，如仍然没找到，则从System ClassLoader中寻找，最后再调用findClass方法来寻找，如要改变类的加载顺序，则可覆盖此方法

   （2）findLoadedClass

        此方法负责从当前ClassLoader实例对象的缓存中寻找已加载的类，调用的为native的方法。

   （3）findClass

        此方法直接抛出ClassNotFoundException，因此需要通过覆盖loadClass或此方法来以自定义的方式加载相应的类。

   （4）findSystemClass

        此方法负责从System ClassLoader中寻找类，如未找到，则继续从Bootstrap ClassLoader中寻找，如仍然为找到，则返回null。

   （5）defineClass

        此方法负责将二进制的字节码转换为Class对象

   （6）resolveClass

        此方法负责完成Class对象的链接，如已链接过，则会直接返回。


-----------------------------------------------------------------------------------------------------------------------
JVM运行时数据区：

    第一块：PC寄存器

        PC寄存器是用于存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。

    第二块：JVM栈

        JVM栈是线程私有的，每个线程创建的同时都会创建JVM栈，JVM栈中存放的为当前线程中局部基本类型的变量（java中定义的八种基本类型：boolean、char、byte、short、int、long、float、double）、部分的返回结果以及Stack Frame，非基本类型的对象在JVM栈上仅存放一个指向堆上的地址

    第三块：堆（Heap）

        它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配，Heap中的对象的内存需要等待GC进行回收。

    第四块：方法区域（Method Area）

        （1）在Sun JDK中这块区域对应的为PermanetGeneration，又称为持久代。

        （2）方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。

    第五块：运行时常量池（Runtime Constant Pool）

        存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配。

    第六块：本地方法堆栈（Native Method Stacks）

        JVM采用本地方法堆栈来支持native方法的执行，此区域用于存储每个native方法调用的状态。



















































